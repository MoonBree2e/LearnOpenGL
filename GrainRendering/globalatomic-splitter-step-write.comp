// _AUGEN_BEGIN_INCLUDE D:\Repo\GrainViewer\share\shaders\grain\globalatomic-splitter.comp.glsl
#version 450 core
// _AUGEN_BEGIN_INCLUDE sys:defines
#define RENDER_TYPE_CACHE
#define STEP_WRITE
// _AUGEN_END_INCLUDE sys:defines
// _AUGEN_BEGIN_INCLUDE sys:settings
#define LOCAL_SIZE_X 128
// _AUGEN_END_INCLUDE sys:settings

layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

struct PointCloundVboEntry {
	vec4 position;
};

struct Counter {
	uint count;
	uint offset;
};

uniform uint uPointCount; // number of elements to draw a priori, ie points per frame
uniform uint uRenderModelCount = 2;
uniform uint uFrameCount;
uniform float uFps = 25.0;
uniform float uTime;

layout(std430, binding = 0) restrict buffer countersSsbo {
	Counter counters[];
};
layout (std430, binding = 2) restrict writeonly buffer elementBufferSsbo {
	uint elementBuffer[];
};

// _AUGEN_BEGIN_INCLUDE D:\Repo\GrainViewer\share\shaders\grain\../include/anim.inc.glsl

// depreciated
uint AnimatedPointId(uint pointId, uint frameCount, uint pointCount, float time, float fps) {
	uint pointCountPerFrame = pointCount / frameCount;
	uint frame = uint(time * fps) % max(1, frameCount);
	return pointId + pointCountPerFrame * frame;
}

// better: pointCount is the point count per frame, not the total size of the buffer
uint AnimatedPointId2(uint pointId, uint frameCount, uint pointCount, float time, float fps) {
	uint frame = uint(time * fps) % max(1, frameCount);
	return pointId + pointCount * frame;
}

// _AUGEN_END_INCLUDE

/**
 * getRenderType(): Get the index of the model to use for a given element.
 * Several options to investigate:
 *   a. cache this before hand in a renderType[] ssbo
        -- RENDER_TYPE_PRECOMPUTE variant
 *   b. compute it directly here, but then compute it twice (steps #1 and #3)
        -- RENDER_TYPE_FORGET variant
 *   c. A trade-off would consist in computing it during step #1 and caching
 *      it for step #3 -- RENDER_TYPE_CACHED variant
 * The best choice depends on whether the limiting factor is memory bandwidth
 * or scalar units.
 */
///////////////////////////////////////////////////////////////////////////////

layout(std430, binding = 1) restrict readonly buffer renderTypeSsbo {
	uint renderType[];
};

uint getRenderType(uint element) {
	return renderType[element];
}

void main() {
	uint i = gl_GlobalInvocationID.x;
	if (i >= uPointCount) return;
	uint type, beforeIncrement;

// Finally write to element buffer
	type = getRenderType(i);
	beforeIncrement = atomicAdd(counters[type].count, 1);
	uint pointId = AnimatedPointId2(i, uFrameCount, uPointCount, uTime, uFps);
	elementBuffer[counters[type].offset + beforeIncrement] = pointId;

}
// _AUGEN_END_INCLUDE
