#version 460

#extension GL_NV_mesh_shader : require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;

//-------------------------------------
// transform_ub: Uniform buffer for transformations
//
layout (std140, binding = 0) uniform uniforms_t
{ 
  mat4 ViewProjectionMatrix;
  mat4 ModelMatrix;
} transform_ub;

//-------------------------------------
// vb: storage buffer for vertices.
//
struct s_vertex
{
	vec4 position;
	vec4 color;
};

layout (std430, binding = 1) buffer _vertices
{
	s_vertex vertices[];
} vb;


//-------------------------------------
// mbuf: storage buffer for meshlets.
//
struct s_meshlet
{
	uint vertices[64];
	uint indices[378]; // up to 126 triangles
	uint vertex_count;
	uint index_count;
};

layout (std430, binding = 2) buffer _meshlets
{
	s_meshlet meshlets[];
} mbuf;



// Mesh shader output block.
//
layout (location = 0) out PerVertexData
{
  vec4 color;
} v_out[];   // [max_vertices]




// Color table for drawing each meshlet with a different color.
//
#define MAX_COLORS 10
vec3 meshletcolors[MAX_COLORS] = {
  vec3(1,0,0), 
  vec3(0,1,0),
  vec3(0,0,1),
  vec3(1,1,0),
  vec3(1,0,1),
  vec3(0,1,1),
  vec3(1,0.5,0),
  vec3(0.5,1,0),
  vec3(0,0.5,1),
  vec3(1,1,1)
  };


void main()
{
	uint group_id = gl_WorkGroupID.x;
	uint thread_id = gl_LocalInvocationID.x;

	uint vertex_count = mbuf.meshlets[group_id].vertex_count;
	for (uint i = 0; i < vertex_count; ++i)
	{
		uint vi = mbuf.meshlets[group_id].vertices[i];

		vec4 Pw = transform_ub.ModelMatrix * vb.vertices[vi].position;
		vec4 P = transform_ub.ViewProjectionMatrix * Pw;

		gl_MeshVerticesNV[i].gl_Position = P;

		v_out[i].color = vb.vertices[vi].color * vec4(meshletcolors[group_id%MAX_COLORS], 1.0);
	}

	uint index_count = mbuf.meshlets[group_id].index_count;
	gl_PrimitiveCountNV = uint(index_count) / 3;

	for (uint i = 0; i < index_count; ++i)
	{
		gl_PrimitiveIndicesNV[i] = uint(mbuf.meshlets[group_id].indices[i]);
	}
}
